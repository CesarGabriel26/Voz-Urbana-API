[
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "criar_conexao",
        "importPath": "conexao",
        "description": "conexao",
        "isExtraImport": true,
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "fechar_conexao",
        "importPath": "conexao",
        "description": "conexao",
        "isExtraImport": true,
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "criar_conexao",
        "importPath": "conexao",
        "description": "conexao",
        "isExtraImport": true,
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "fechar_conexao",
        "importPath": "conexao",
        "description": "conexao",
        "isExtraImport": true,
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "criar_conexao",
        "importPath": "conexao",
        "description": "conexao",
        "isExtraImport": true,
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "fechar_conexao",
        "importPath": "conexao",
        "description": "conexao",
        "isExtraImport": true,
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "Petition",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Report",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "RealDictCursor",
        "importPath": "psycopg2.extras",
        "description": "psycopg2.extras",
        "isExtraImport": true,
        "detail": "psycopg2.extras",
        "documentation": {}
    },
    {
        "label": "RealDictCursor",
        "importPath": "psycopg2.extras",
        "description": "psycopg2.extras",
        "isExtraImport": true,
        "detail": "psycopg2.extras",
        "documentation": {}
    },
    {
        "label": "RealDictCursor",
        "importPath": "psycopg2.extras",
        "description": "psycopg2.extras",
        "isExtraImport": true,
        "detail": "psycopg2.extras",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "vercel_blob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "vercel_blob",
        "description": "vercel_blob",
        "detail": "vercel_blob",
        "documentation": {}
    },
    {
        "label": "bcrypt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bcrypt",
        "description": "bcrypt",
        "detail": "bcrypt",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "get_swaggerui_blueprint",
        "importPath": "flask_swagger_ui",
        "description": "flask_swagger_ui",
        "isExtraImport": true,
        "detail": "flask_swagger_ui",
        "documentation": {}
    },
    {
        "label": "dotenv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dotenv",
        "description": "dotenv",
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "usuarios_bp",
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "isExtraImport": true,
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "reports_bp",
        "importPath": "routes.reports",
        "description": "routes.reports",
        "isExtraImport": true,
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "petitions_bp",
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "isExtraImport": true,
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "imagem_bp",
        "importPath": "routes.imagem",
        "description": "routes.imagem",
        "isExtraImport": true,
        "detail": "routes.imagem",
        "documentation": {}
    },
    {
        "label": "psycopg2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psycopg2",
        "description": "psycopg2",
        "detail": "psycopg2",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "nova_peticao",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def nova_peticao():\n    data = request.get_json()\n    petition = Petition.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    # Definir status inicial e verificar data_limite\n    status_inicial = 0  # 0 = 'Criada'\n    data_limite = petition.data_limite if petition.data_limite else (datetime.now() + timedelta(days=30))  # Exemplo: 30 dias no futuro\n    try:\n        cursor.execute(",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "list_peticoes",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def list_peticoes():\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"select * from peticoes\")\n        petitions = cursor.fetchall()\n        if petitions:\n            return jsonify({'message': 'Found', 'content': petitions}), 200\n        else:\n            return jsonify({'message': 'No petitions found', 'content': []}), 200",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "get_petitions_by_id",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def get_petitions_by_id(id):\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"SELECT * FROM peticoes WHERE id = %s\", (id,))\n        petitions = cursor.fetchone()\n        if petitions:\n            return jsonify({'content': petitions}), 200\n        else:\n            return jsonify({'message': 'petition not found'}), 404",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "get_petitions_by_user",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def get_petitions_by_user(user_id):\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"SELECT * FROM peticoes WHERE user_id = %s\", (user_id,))\n        petitions = cursor.fetchall()\n        if petitions:\n            return jsonify({'content': petitions}), 200\n        else:\n            return jsonify({'message': 'No petitions found for this user'}), 200",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "update_peticao",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def update_peticao(id):\n    data = request.get_json()\n    updated_petition = Petition.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        # Verificar se a petição existe\n        cursor.execute(\"SELECT * FROM peticoes WHERE id = %s\", (id,))\n        existing_petition = cursor.fetchone()\n        if not existing_petition:",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "delete_peticao",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def delete_peticao(id):\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        # Verificar se a petição existe\n        cursor.execute(\"SELECT * FROM peticoes WHERE id = %s\", (id,))\n        petition = cursor.fetchone()\n        if not petition:\n            return jsonify({'error': 'Petition not found'}), 404\n        # Deletar a petição",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "check_signatures",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def check_signatures(id):\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"SELECT signatures, required_signatures FROM peticoes WHERE id = %s\", (id,))\n        petition = cursor.fetchone()\n        if petition:\n            if petition['signatures'] >= petition['required_signatures']:\n                return jsonify({'message': 'Petition has reached the required number of signatures'}), 200\n            else:",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "check_all_open_petitions",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def check_all_open_petitions():\n    conn = criar_conexao()\n    try:\n        with conn.cursor() as cursor:\n            cursor.execute(\"SELECT * FROM peticoes WHERE aberto = TRUE\")\n            result = cursor.fetchall()\n            if not result:\n                return jsonify({'message': 'No open petitions found'}), 200\n            open_petitions = []\n            data_atual = datetime.now()",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "check_timer",
        "kind": 2,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "def check_timer(petition_id):\n    conn = criar_conexao()\n    try:\n        with conn.cursor() as cursor:\n            # Busca a petição pelo ID, apenas se estiver aberta\n            cursor.execute(\"SELECT data_limite FROM peticoes WHERE id = %s AND aberto = TRUE\", (petition_id,))\n            result = cursor.fetchone()\n            if not result:\n                return jsonify({'error': 'Petição não encontrada ou já está fechada.'}), 404\n            data_limite = result[0]",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "petitions_bp",
        "kind": 5,
        "importPath": "routes.abaixo_assinados",
        "description": "routes.abaixo_assinados",
        "peekOfCode": "petitions_bp = Blueprint('peticoes', __name__)\n@petitions_bp.route('/create', methods=['POST'])\ndef nova_peticao():\n    data = request.get_json()\n    petition = Petition.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    # Definir status inicial e verificar data_limite\n    status_inicial = 0  # 0 = 'Criada'\n    data_limite = petition.data_limite if petition.data_limite else (datetime.now() + timedelta(days=30))  # Exemplo: 30 dias no futuro",
        "detail": "routes.abaixo_assinados",
        "documentation": {}
    },
    {
        "label": "upload_imagem",
        "kind": 2,
        "importPath": "routes.imagem",
        "description": "routes.imagem",
        "peekOfCode": "def upload_imagem():\n    arquivo = request.files.get('imagem')  # Supondo que a imagem está no campo 'imagem'\n    if not arquivo:\n        return jsonify({\"error\": \"Nenhuma imagem fornecida\"}), 400\n    try:\n        # Obtém o nome do arquivo\n        nome_arquivo = arquivo.filename\n        # Usa o método put da biblioteca vercel_blob para enviar a imagem\n        data_imagem = vercel_blob.put(nome_arquivo, arquivo.read(), {})  # Envia o arquivo para o Blob\n        return jsonify({\"message\": \"success\", \"content\": data_imagem}), 200",
        "detail": "routes.imagem",
        "documentation": {}
    },
    {
        "label": "delete_imagem",
        "kind": 2,
        "importPath": "routes.imagem",
        "description": "routes.imagem",
        "peekOfCode": "def delete_imagem():\n    try:\n        data = request.get_json()  # Obtém os dados do corpo da requisição\n        nome_arquivo = data.get('link')  # Supondo que o link da imagem seja passado com a chave 'link'\n        print(nome_arquivo)\n        if not nome_arquivo:\n            return jsonify({\"error\": \"Link da imagem não fornecido\"}), 400\n        # Usa o método delete da biblioteca vercel_blob para remover a imagem\n        vercel_blob.delete(nome_arquivo)  # Remove o arquivo do Blob\n        return jsonify({\"message\": \"Imagem deletada com sucesso\", \"success\": True}), 200",
        "detail": "routes.imagem",
        "documentation": {}
    },
    {
        "label": "imagem_bp",
        "kind": 5,
        "importPath": "routes.imagem",
        "description": "routes.imagem",
        "peekOfCode": "imagem_bp = Blueprint('imagem', __name__)\n@imagem_bp.route('/upload', methods=['POST'])\ndef upload_imagem():\n    arquivo = request.files.get('imagem')  # Supondo que a imagem está no campo 'imagem'\n    if not arquivo:\n        return jsonify({\"error\": \"Nenhuma imagem fornecida\"}), 400\n    try:\n        # Obtém o nome do arquivo\n        nome_arquivo = arquivo.filename\n        # Usa o método put da biblioteca vercel_blob para enviar a imagem",
        "detail": "routes.imagem",
        "documentation": {}
    },
    {
        "label": "novo_report",
        "kind": 2,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "def novo_report():\n    data = request.get_json()\n    # Verifique se user_id está presente\n    if 'user_id' not in data:\n        return jsonify({'error': 'user_id is required'}), 400\n    report = Report.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        cursor.execute(",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "list_reports",
        "kind": 2,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "def list_reports():\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"SELECT * FROM reports\")\n        reports = cursor.fetchall()\n        if reports:\n            return jsonify({'content': reports}), 200\n        else:\n            return jsonify({'message': 'empty', 'content': []}), 200",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "get_petitions_by_id",
        "kind": 2,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "def get_petitions_by_id(id):\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"SELECT * FROM reports WHERE id = %s\", (id,))\n        petitions = cursor.fetchone()\n        if petitions:\n            return jsonify({'message': \"found\", 'content': petitions}), 200\n        else:\n            return jsonify({'message': 'report not found'}), 404",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "get_reports_by_user",
        "kind": 2,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "def get_reports_by_user(user_id):\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    try:\n        cursor.execute(\"SELECT * FROM reports WHERE user_id = %s\", (user_id,))\n        reports = cursor.fetchall()\n        if reports:\n            return jsonify({'content': reports}), 200\n        else:\n            return jsonify({'error': 'No reports found for this user'}), 404",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "update_report",
        "kind": 2,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "def update_report(id):\n    data = request.get_json()\n    updated_report = Report.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        # Verificar se o report existe\n        cursor.execute(\"SELECT * FROM reports WHERE id = %s\", (id,))\n        existing_report = cursor.fetchone()\n        if not existing_report:",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "delete_report",
        "kind": 2,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "def delete_report(id):\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        # Verificar se o report existe\n        cursor.execute(\"SELECT * FROM reports WHERE id = %s\", (id,))\n        report = cursor.fetchone()\n        if not report:\n            return jsonify({'error': 'Report not found'}), 404\n        # Deletar o report",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "reports_bp",
        "kind": 5,
        "importPath": "routes.reports",
        "description": "routes.reports",
        "peekOfCode": "reports_bp = Blueprint('reports', __name__)\n@reports_bp.route('/create', methods=['POST'])\ndef novo_report():\n    data = request.get_json()\n    # Verifique se user_id está presente\n    if 'user_id' not in data:\n        return jsonify({'error': 'user_id is required'}), 400\n    report = Report.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()",
        "detail": "routes.reports",
        "documentation": {}
    },
    {
        "label": "new_usuario",
        "kind": 2,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "def new_usuario():\n    data = request.get_json()\n    user = User.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    hashed_password = bcrypt.hashpw(user.senha.encode('utf-8'), bcrypt.gensalt())\n    try:\n        cursor.execute(\n            \"INSERT INTO usuarios (nome, email, senha, pfp, cpf) VALUES (%s, %s, %s, %s, %s)\",\n            (user.nome, user.email, hashed_password.decode('utf-8'), user.pfp, user.cpf)",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "def login():\n    data = request.get_json()\n    email = data.get('email')\n    senha = data.get('senha')\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)  # Usando RealDictCursor para retornar resultados como dicionário\n    try:\n        cursor.execute(\"SELECT * FROM usuarios WHERE email = %s\", (email,))\n        user_data  = cursor.fetchone()\n        if user_data :",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "passwordCheck",
        "kind": 2,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "def passwordCheck(id):\n    data = request.get_json()\n    senha = data.get('senha')\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)  # Usando RealDictCursor para retornar resultados como dicionário\n    try:\n        cursor.execute(\"SELECT * FROM usuarios WHERE id = %s\", (id,))\n        user_data  = cursor.fetchone()\n        if user_data :\n            if bcrypt.checkpw(senha.encode('utf-8'), user_data['senha'].encode('utf-8')):",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "get_usuario_by_id",
        "kind": 2,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "def get_usuario_by_id(id):\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        # Verificar se o usuário existe\n        cursor.execute(\"SELECT * FROM usuarios WHERE id = %s\", (id,))\n        user = cursor.fetchone()\n        if not user:\n            return jsonify({'error': 'User not found'}), 404\n        return jsonify({'message': 'Found', \"content\": user}), 200",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "delete_usuario",
        "kind": 2,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "def delete_usuario(id):\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    try:\n        # Verificar se o usuário existe\n        cursor.execute(\"SELECT * FROM usuarios WHERE id = %s\", (id,))\n        user = cursor.fetchone()\n        if not user:\n            return jsonify({'error': 'User not found'}), 404\n        # Deletar o usuário",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "update_usuario",
        "kind": 2,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "def update_usuario(id):\n    data = request.get_json()\n    updated_user = User.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)  # Usando RealDictCursor para retornar resultados como dicionário\n    try:\n        # Verificar se o usuário existe\n        cursor.execute(\"SELECT * FROM usuarios WHERE id = %s\", (id,))\n        existing_user = cursor.fetchone()\n        if not existing_user:",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "usuarios_bp",
        "kind": 5,
        "importPath": "routes.usuario",
        "description": "routes.usuario",
        "peekOfCode": "usuarios_bp = Blueprint('usuarios', __name__)\n@usuarios_bp.route('/create', methods=['POST'])\ndef new_usuario():\n    data = request.get_json()\n    user = User.from_dict(data)\n    conn = criar_conexao()\n    cursor = conn.cursor()\n    hashed_password = bcrypt.hashpw(user.senha.encode('utf-8'), bcrypt.gensalt())\n    try:\n        cursor.execute(",
        "detail": "routes.usuario",
        "documentation": {}
    },
    {
        "label": "swagger_json",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def swagger_json():\n    if os.path.exists(\"swagger_spec.json\"):\n        with open(\"swagger_spec.json\", 'r') as json_file:\n            swagger_spec = json.load(json_file)\n            return swagger_spec\n    else:\n        return {}\n@app.route('/')\ndef main():\n    return \"Olá Mundo!!!!\"",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def main():\n    return \"Olá Mundo!!!!\"\nif __name__ == \"__main__\":\n    app.run()",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)\ndotenv.load_dotenv()\n### Swagger configuration ###\nSWAGGER_URL = '/docs'  # URL para acessar a documentação\nAPI_URL = '/swagger.json'  # Caminho para o arquivo JSON de especificação Swagger\nswaggerui_blueprint = get_swaggerui_blueprint(\n    SWAGGER_URL,  # Swagger UI URL\n    API_URL,  # Swagger arquivo JSON URL\n    config={  # Configurações adicionais do Swagger UI",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "SWAGGER_URL",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "SWAGGER_URL = '/docs'  # URL para acessar a documentação\nAPI_URL = '/swagger.json'  # Caminho para o arquivo JSON de especificação Swagger\nswaggerui_blueprint = get_swaggerui_blueprint(\n    SWAGGER_URL,  # Swagger UI URL\n    API_URL,  # Swagger arquivo JSON URL\n    config={  # Configurações adicionais do Swagger UI\n        'app_name': \"API Voz Urbana\"\n    }\n)\napp.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "API_URL",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "API_URL = '/swagger.json'  # Caminho para o arquivo JSON de especificação Swagger\nswaggerui_blueprint = get_swaggerui_blueprint(\n    SWAGGER_URL,  # Swagger UI URL\n    API_URL,  # Swagger arquivo JSON URL\n    config={  # Configurações adicionais do Swagger UI\n        'app_name': \"API Voz Urbana\"\n    }\n)\napp.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)\napp.register_blueprint(usuarios_bp, url_prefix='/usuarios')",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "swaggerui_blueprint",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "swaggerui_blueprint = get_swaggerui_blueprint(\n    SWAGGER_URL,  # Swagger UI URL\n    API_URL,  # Swagger arquivo JSON URL\n    config={  # Configurações adicionais do Swagger UI\n        'app_name': \"API Voz Urbana\"\n    }\n)\napp.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)\napp.register_blueprint(usuarios_bp, url_prefix='/usuarios')\napp.register_blueprint(reports_bp, url_prefix='/reports')",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "criar_conexao",
        "kind": 2,
        "importPath": "conexao",
        "description": "conexao",
        "peekOfCode": "def criar_conexao():\n    return psycopg2.connect(\n        host=os.getenv(\"POSTGRES_HOST\"),\n        user=os.getenv(\"POSTGRES_USER\"),\n        password=os.getenv(\"POSTGRES_PASSWORD\"),\n        dbname=os.getenv(\"POSTGRES_DATABASE\"),\n        sslmode=\"require\"  # Esse valor é passado diretamente, como no seu URL\n    )\ndef fechar_conexao(conexao):\n    if conexao:",
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "fechar_conexao",
        "kind": 2,
        "importPath": "conexao",
        "description": "conexao",
        "peekOfCode": "def fechar_conexao(conexao):\n    if conexao:\n        conexao.close()",
        "detail": "conexao",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "models",
        "description": "models",
        "peekOfCode": "class User:\n    def __init__(self, nome, senha, email, cpf, pfp=None, user_id=None):\n        self.id = user_id\n        self.nome = nome\n        self.senha = senha\n        self.email = email\n        self.cpf = cpf\n        self.pfp = pfp\n    def to_dict(self):\n        return {",
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Report",
        "kind": 6,
        "importPath": "models",
        "description": "models",
        "peekOfCode": "class Report:\n    def __init__(self, latitude, longitude, titulo, conteudo, imagem, data, user_id, report_id=None, aceito=False):\n        self.id = report_id\n        self.latitude = latitude\n        self.longitude = longitude\n        self.titulo = titulo\n        self.conteudo = conteudo\n        self.imagem = imagem\n        self.aceito = aceito\n        self.data = data",
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Petition",
        "kind": 6,
        "importPath": "models",
        "description": "models",
        "peekOfCode": "class Petition:\n    def __init__(self, user_id, title, content, signatures=0, required_signatures=100, status=0, data_limite=None, petition_id=None):\n        self.id = petition_id\n        self.user_id = user_id\n        self.title = title\n        self.content = content\n        self.signatures = signatures\n        self.required_signatures = required_signatures\n        self.status = status\n        self.data_limite = data_limite",
        "detail": "models",
        "documentation": {}
    }
]